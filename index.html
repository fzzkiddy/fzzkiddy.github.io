<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  

  
  
  
  
  
  
  <title>网瘾少女--小双鱼</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="网瘾少女--小双鱼">
<meta property="og:url" content="http://fzzkiddy.github.io/index.html">
<meta property="og:site_name" content="网瘾少女--小双鱼">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网瘾少女--小双鱼">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="网瘾少女--小双鱼" rel="home">网瘾少女--小双鱼</a>
      </h1>
      
        <h2 class="site-description">
          <a href="/" id="subtitle">猫系少女～好养=。= Tiramisu~</a>
        </h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-2020年终总结" class="post-2020年终总结 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2020/01/21/2020年终总结/">2020年终总结</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://fzzkiddy.github.io/2020/01/21/2020年终总结/" data-id="ck5nh1ozn0000i2cdz4ggbl80" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p> 好像再不整理出来，真的农历新年都要过去了。<br> 今年的关键词是： <code>充实、平稳、遗憾、感恩、学会试错</code><br><code>感悟：人生本就是一个试错的过程，大胆尝试才会有新的体验</code><br>回顾了一下这一整年所有的工作。收获颇多，也感谢一路以来支持我的伙伴。</p>
<h2 id="提升影响力"><a href="#提升影响力" class="headerlink" title="提升影响力"></a>提升影响力</h2><p>今年工作的重点还是在国际方向。所以已经跟国际方向的小伙伴们建立了深厚的战略合作友谊。<br>默契也慢慢形成。虽然还是会出现一些小纰漏。但大家能够越来越熟练、越来越快速的解决问题了。<br>从之前听从安排活动再进行开发。到现在能够完全把控一个活动流程的节奏。以及在国际方向的活动，让相关部门的同事能够有问题的时候，第一时间来找我咨询技术相关的问题，也是影响力提升的一种表现吧。</p>
<h2 id="完成了第一个自己做主的项目"><a href="#完成了第一个自己做主的项目" class="headerlink" title="完成了第一个自己做主的项目"></a>完成了第一个自己做主的项目</h2><p>而每次活动结束之后，都会有整理数据上报给产品这一块内容。方法很原始，就是直接写sql，从工具表中获取了产品想要的数据之后，用CV大法给他整理到表格里。作为一个程序员来讲，是非常讨厌这种所谓“劳动力”工作的。所以在这种方式用了几个活动之后，为了方便产品查询数据，也为了提高工作效率，达到一劳永逸的效果。由我推动并执行完成了第一个自己做主的项目。</p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>活动做的多了，自然而然接触了大量数据库相关的知识。尤其是直播方向的活动，国际用户越来越多，数据量越来越大，对于大量数据的处理，从一开始的摸不到头脑，遇过几个大坑，栽过几次跟头，痛定思痛之后到现在的轻车熟路，也是一种成长。“工程化”思想，是在下半年OneOnOne之后的思考。学习了《软件工程之美》，懂得了如何整体的把控一个项目。宝玉说，所有的事情，都把它想成一个项目来做。做起来都会轻松一些。</p>
<h2 id="带飞了两个新人"><a href="#带飞了两个新人" class="headerlink" title="带飞了两个新人"></a>带飞了两个新人</h2><p>这大概是我最不想说，但是又必须提及的事情。很幸运的是，今年能够带新人了。但不够幸运的是，两个新人都被我带“飞了”。或许是自己的工作经验还不够成熟。就像不是每一个优秀的学生都可以成为教书育人的老师一样。虽然我已经算是公司的“中年人”（ps：不称为老人的原因是，还有一大批比我年长的同事呢），但在带人这方面，我属实是个小白，也会观察其他同事的方式，学习经验。但效果不太理想。于是，第一个同学的“不对付”，以及第二个同学的“不适应”。导致他们都相继离开了。而我，还是没找到一个一起奋斗的小伙伴。希望这个愿望能在2020年实现。</p>
<h2 id="完成的flag"><a href="#完成的flag" class="headerlink" title="完成的flag"></a>完成的flag</h2><p>所有的事情都是需要坚持，才会有结果的。比如今年立下的flag说，一定要把字练好。虽然，现在还是没有写出让人看到就“哇”的文字，但是至少在签字或者写文章的时候，我不再惧怕让别人看到我写的字了。这也是一种进步吧。所以明年继续。这段文字主要起到了承上启下的作用，只是想要引出下面这段文字</p>
<h2 id="倒下的flag"><a href="#倒下的flag" class="headerlink" title="倒下的flag"></a>倒下的flag</h2><p>比如，接入kafka，这个事情呢，本来是一个非常好的机会，但是算是没抓住吧。在最忙碌的两个月，对Kafka的不了解，以及忙着赶工，加快活动开发进度，导致把这件事情搁置了，直到大大过来接手。大家都是第一次了解kafka，但大大明显就比我容易上手多了。这大概也是我与资深工程师的区别吧。</p>
<h2 id="技术-提升"><a href="#技术-提升" class="headerlink" title="技术 提升"></a>技术 提升</h2><p>今年对自己的编码风格有了巨大的提升，无论是周围小伙伴的帮助还是自己的彻悟，以前只能让机器读懂的代码变成了能让人读懂的代码。也开始自己规划项目流程，搭建项目框架。在数据库方面，也有了不小的提升。</p>
<h2 id="明年继续的事情"><a href="#明年继续的事情" class="headerlink" title="明年继续的事情"></a>明年继续的事情</h2><p>飞书小程序这个项目。算是突如其来的奖励吧。上面的机会没抓住，我总不能两次掉入同一条河流。接下的事情，就要打个漂亮的“仗”。12月份之后，除了完成日常的活动工作。我多了一件事情，就是去了解小程序。开发项目。从0到1的孵化出一个完整的项目。这件事情对我来讲，不仅很有意思，更有意义。12月份以来，我明显感觉自己认识了更多公司各个部门的同事。对于我这个不爱care工作本身以外事情的人来讲，是个很大的进步了。之前认为与人沟通是一件十分困难的事情。因为总怕说错话，总觉得会讲不清楚，别人也没有那么多耐心来听你讲一些没有重点的话。所以每次沟通之前，我都会认真的整理笔记，因为脑子不好使。。。所以会把想问的问题总结下来。所谓好记性不如烂笔头就是这个道理吧。但是，当你思路清晰，脑子里知道要讲什么时候，你会发现，沟通并不是一件困难的事情。<br>明年，“学会沟通”将是我的一个重要flag。<br>以及，马上就要孵化出的两个小程序项目：咖啡点单，wifi连接。都将是检验我这两个月以来努力的成果，也希望能在岁末年初之际能给自己一个漂亮的答卷吧。</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>活动方向，希望能够提供更多的帮助给非技术的同事。提高整个项目的效率。<br>无论是推动项目的完成，还是推动新项目的开展。都希望能够更上一层楼吧。<br>更多的希望能够像身边的同事学习，编程的思想，彻底抛弃“野路子出来的”标签。<br>改掉了看书总是半途而废 的毛病。也希望明年能够看更多技术类型的书。<br>在分享给大家的时候能够更专业一些。<br>希望在时间规划上，更合理一些。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2020/01/21/2020年终总结/">
    <time datetime="2020-01-21T05:54:20.000Z" class="entry-date">
        2020-01-21
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-webpack入门" class="post-webpack入门 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://fzzkiddy.github.io/2018/07/11/webpack入门/" data-id="ck5nh1p0e000ei2cdo0afy8ov" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>— title: webpack入门<br>date: 2018-07-09 18:10:19</p>
<h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><p> webpack 小白初学笔记</p>
<h4 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h4><p>  对webpack 的通俗解释：<code>模块打包机</code><br>    分析项目结构，找到JavaScript模块以及其他一些浏览器不能直接运行的拓展语言（Scss, TypeScript等），将其转换和打包为合适的格式共浏览器使用。<br>  webpack 的工作方式： 把你的项目当作一个整体，通过一个给定的主文件（如：index.js）, Webpack 将从这个文件开始找到你项目的所有依赖文件，使用loaders处理它们。最后打包为一个或多个浏览器可识别的JavaScript文件。</p>
<h3 id="使用webpack"><a href="#使用webpack" class="headerlink" title="使用webpack"></a>使用webpack</h3><pre><code>// 全局安装
npm install -g webpack
// 安装到项目目录
npm install --save-dev webpack
// 前提是项目中有package.json 文件
</code></pre><hr>
<p>npm的start命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用npm start就可以执行其对于的命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build，我们在命令行中输入npm start试试，输出结果如下    </p>
<blockquote>
<p>注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</p>
</blockquote>
<p>浏览器监听代码修改，</p>
<blockquote>
<p>npm install –save-dev webpack-dev-server</p>
</blockquote>
<hr>
<ul>
<li>ExtractTextPlugin：分离CSS和JS文件<blockquote>
<p>npm install –save-dev extract-text-webpack-plugin</p>
</blockquote>
</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/07/11/webpack入门/">
    <time datetime="2018-07-11T03:06:46.000Z" class="entry-date">
        2018-07-11
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-CommonJs" class="post-CommonJs post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/07/10/CommonJs/">CommonJs</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://fzzkiddy.github.io/2018/07/10/CommonJs/" data-id="ck5nh1ozu0002i2cdayp4kdy0" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>CommonJs定义模块类型：<br> 模块引用 | 模块定义 | 模块标识<br> —|—|—<br> require  | exports  | module   </p>
<table>
<thead>
<tr>
<th>模块引用</th>
<th>模块定义</th>
<th>模块标识 </th>
</tr>
</thead>
<tbody>
<tr>
<td>require</td>
<td>exports</td>
<td>module</td>
</tr>
</tbody>
</table>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/07/10/CommonJs/">
    <time datetime="2018-07-10T02:36:43.000Z" class="entry-date">
        2018-07-10
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-npm" class="post-npm post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/07/09/npm/">npm</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://fzzkiddy.github.io/2018/07/09/npm/" data-id="ck5nh1p09000bi2cdrtxfoqof" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="viewport-units-buggyfill"><a href="#viewport-units-buggyfill" class="headerlink" title="viewport-units-buggyfill"></a>viewport-units-buggyfill</h3>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/07/09/npm/">
    <time datetime="2018-07-09T07:42:06.000Z" class="entry-date">
        2018-07-09
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-图片预加载" class="post-图片预加载 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/07/09/图片预加载/">图片预加载</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://fzzkiddy.github.io/2018/07/09/图片预加载/" data-id="ck5nh1p0c000ci2cd5cly8jmb" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="Skeleton-Screen的由来-加载占位图"><a href="#Skeleton-Screen的由来-加载占位图" class="headerlink" title="Skeleton Screen的由来 加载占位图"></a>Skeleton Screen的由来 加载占位图</h3><p>javascript，创建Image对象，然后把这些对象的src属性设置成要 加载的图片地址也能触发浏览器加载图片，利用这一点就能实现图片预加载的功能</p>
<ul>
<li>图片加载问题<br>  a. 进度问题<br>  进度条设置 ： 已加载文件数／总的文件数<br>  b. 图片加载失败的问题<br>  图片加载失败时，不应该影响加载器功能<br>  c. 图片加载超时问题<br>  图片不能加载太久，否则用户一直停留在加载效果上，看不到主内容。应该给每个图片设置一个加载的超时时间。如果图片正在超时时间之后，还没有加载完，就该主动放弃加载，通知外部上下文加载完毕，显示主内容。<br>  <img src="../img/loadImg/1.png"></li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/07/09/图片预加载/">
    <time datetime="2018-07-09T02:58:58.000Z" class="entry-date">
        2018-07-09
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-React-router" class="post-React-router post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/03/23/React-router/">React_router</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://fzzkiddy.github.io/2018/03/23/React-router/" data-id="ck5nh1ozw0003i2cda48m1qc2" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>React Route</p>
<h1 id="import-Route-Redirect-from-‘react-router-dom’"><a href="#import-Route-Redirect-from-‘react-router-dom’" class="headerlink" title="import {Route, Redirect} from ‘react-router-dom’"></a>import {Route, Redirect} from ‘react-router-dom’</h1><route path="/">

<h1 id="Route-渲染的三种方式"><a href="#Route-渲染的三种方式" class="headerlink" title="Route 渲染的三种方式"></a>Route 渲染的三种方式</h1><ul>
<li>component : 一个React 组件。<br>  <code>&lt;Route path=&#39;/index&#39; component={Index}&gt;</code></li>
<li>render : 一个返回React element 的函数 当匹配成功后调用该函数。<code>对于行级渲染与需要向元素传入额外参数的操作更有用</code><br><code>&lt;Route path=&#39;/path/:type&#39; render={({match})=&gt; {return &lt;Schedule /&gt;    }}</code><br>  其中 ‘/path/:type’ :type这种写法， 意味着/path/后的路径名将会被获取并存在match.params.type 中</li>
<li>children: 返回一个React element 函数 <code>与上述两个参数不同，无论route是否匹配当前location，都会被渲染</code></li>
<li>children 常用在path无法匹配时呈现的‘空’ 状态</li>
</ul>
<h1 id="Redirect-、Prompt、Link"><a href="#Redirect-、Prompt、Link" class="headerlink" title="Redirect 、Prompt、Link"></a>Redirect 、Prompt、Link</h1><ul>
<li><p>Link  属性<br><link to="/index"><br>activeClassName  当被点击时，的className接受一个它的值（activeClassName）默认情况下他是不激活的。<br>activeStyle中的值会添加到转换后的<a> 中，样式是style=’color:red’</a></p>
<p>onClick(e)<br>自定义单击事件处理程序<br>e.preventDefault() 阻止默认事件<br>e.stopPropagation() 阻止事件冒泡</p>
<p>onlyActiveOnIndex<br>如果onlyActiveOnIndex的值是true,中的路径完全匹配时才会连接指定路由</p>
</li>
</ul>
</route>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/03/23/React-router/">
    <time datetime="2018-03-23T07:53:13.000Z" class="entry-date">
        2018-03-23
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-redux" class="post-redux post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/03/21/redux/">redux</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://fzzkiddy.github.io/2018/03/21/redux/" data-id="ck5nh1p07000ai2cd4yi5ff5f" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Store 就是保存数据的地方，整个应用只能有一个Store</p>
<ul>
<li><p>createStore 函数 来生成 Store<br>import { createStore } from ‘redux’;<br>const store = createStore(fn);</p>
</li>
<li><p>State<br>  当前时刻的State ，可以通过store.getState() 拿到<br>  import { createStore } from ‘redux’;<br>  const store = createStore(fn);<br>  const state = store.getState();</p>
</li>
<li><p>Redex  规定 ，一个State 对应一个View 。 只要 State 相同，View 就相同。 你知道State，就知道View 是什么样的。</p>
</li>
<li><p>Action<br>  用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的<br>  Action 就是 View 发出的通知，表示 State 应该要发生变化了<br>  Action 是一个对象。其中的<code>type属性是必须的</code>！</p>
<pre><code>const action = {
  type: &apos;ADD_TODO&apos;,
  payload: &apos;Learn Redux&apos;
};
</code></pre><p>  Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux。</p>
</li>
<li><p>Action Creator<br>  View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫<br>  <code>Action Creator</code></p>
<pre><code>const ADD_TODO = &apos;添加 TODO&apos;;

function addTodo(text) {
  return {
    type: ADD_TODO,
    text
  }
}

const action = addTodo(&apos;Learn Redux&apos;);
</code></pre></li>
<li><p>store.dispatch()<br>  <code>store.dispatch()</code>是 View 发出 Action 的唯一方法。</p>
<pre><code>import { createStore } from &apos;redux&apos;;
const store = createStore(fn);

store.dispatch({
  type: &apos;ADD_TODO&apos;,
  payload: &apos;Learn Redux&apos;
});
</code></pre><p>  结合上面 Action Creator 代码可改写为</p>
<pre><code>store.dispatch(addTodo(&apos;Learn Redux&apos;));
</code></pre></li>
<li><p>Reducer<br>  Store 收到Action 以后，必须给出一个新的State， 这样View 才会发生变化，这种 State 的计算过程就叫做Reducer<br>  Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State</p>
<pre><code>const reducer = function (state, action) {
  // ...
  return new_state;
};

const defaultState = 0;
const reducer = (state = defaultState, action) =&gt; {
  switch (action.type) {
    case &apos;ADD&apos;:
      return state + action.payload;
    default: 
      return state;
  }
};

const state = reducer(1, {
  type: &apos;ADD&apos;,
  payload: 2
});
</code></pre><p>  上面代码中，reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。<br>  <code>store.dispatch</code>方法会触发 Reducer 的自动执行。<br>  createStore 接受 Reducer 作为参数，生成一个新的 Store。以后每当 store.dispatch 发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。</p>
<pre><code>const actions = [
  { type: &apos;ADD&apos;, payload: 0 },
  { type: &apos;ADD&apos;, payload: 1 },
  { type: &apos;ADD&apos;, payload: 2 }
];

const total = actions.reduce(reducer, 0); // 3
</code></pre></li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/03/21/redux/">
    <time datetime="2018-03-21T09:50:50.000Z" class="entry-date">
        2018-03-21
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="node-版本控制" class="node-版本控制 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/03/02/版本控制/">node版本控制</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://fzzkiddy.github.io/2018/03/02/版本控制/" data-id="ck5nh1p0n000fi2cdkobtlisf" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="node-版本安装"><a href="#node-版本安装" class="headerlink" title="node 版本安装"></a>node 版本安装</h1><ul>
<li>使用npm 安装一个模块 n 到全局<blockquote>
<p>npm  install  -g  n</p>
</blockquote>
</li>
<li>使用 n 加版本号 就可以安装其他版本了<blockquote>
<p>sudo n 6.1.0<br>mac 需要sudo 权限</p>
</blockquote>
</li>
</ul>
<h1 id="node-多版本切换"><a href="#node-多版本切换" class="headerlink" title="node 多版本切换"></a>node 多版本切换</h1><ul>
<li>查看node版本<blockquote>
<p>n<br>(前面有个o)<br>你可以通过移动上下方向键来选择要使用的版本，最后按回车生效。<br>n </p>
<blockquote>
<p>0.10.1<br>0.10.15<br>o<br>   0.10.1<br>   0.11.8</p>
</blockquote>
</blockquote>
</li>
<li>安装最新版本<blockquote>
<p>n latest</p>
</blockquote>
</li>
<li>安装稳定版本<blockquote>
<p>n stable</p>
</blockquote>
</li>
<li>删除某个版本<blockquote>
<p>n rm 0.10.1</p>
</blockquote>
</li>
<li>以指定的版本来执行版本<blockquote>
<p>n use 0.10.21 some.js</p>
</blockquote>
</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/03/02/版本控制/">
    <time datetime="2018-03-02T03:44:40.000Z" class="entry-date">
        2018-03-02
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-Shell教程" class="post-Shell教程 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/02/28/Shell教程/">Shell教程</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://fzzkiddy.github.io/2018/02/28/Shell教程/" data-id="ck5nh1ozz0005i2cd5z3qwc1i" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><pre><code>touch  文件名
</code></pre><h3 id="新建文件夹"><a href="#新建文件夹" class="headerlink" title="新建文件夹"></a>新建文件夹</h3><pre><code>mkdir  文件
</code></pre><h3 id="运行shell脚本"><a href="#运行shell脚本" class="headerlink" title="运行shell脚本"></a>运行shell脚本</h3><pre><code>./test.sh
</code></pre><p>  注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p>
<ul>
<li>作为可执行程序<pre><code>chmod +x ./test.sh  #使脚本具有执行权限
./test.sh  #执行脚本
</code></pre></li>
<li>作为解释器参数<br>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。<pre><code>  /bin/sh test.sh
/bin/php test.php
</code></pre></li>
</ul>
<h3 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h3><blockquote>
<p>your_name=”runoob.com”</p>
</blockquote>
<p>  变量名和等号之间不能有空格</p>
<ul>
<li><p>变量名的命名须遵循如下规则：</p>
<p>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。<br>中间不能有空格，可以使用下划线（_）。<br>不能使用标点符号。<br>不能使用bash里的关键字（可用help命令查看保留关键字）。</p>
</li>
<li>有效的变量名<blockquote>
<p>RUNOOB<br>LD_LIBRARY_PATH<br>_var<br>var2</p>
</blockquote>
</li>
<li>无效的变量名<blockquote>
<p>?var=123<br>user*name=runoob</p>
</blockquote>
</li>
<li>除了显式地直接赋值，还可以用语句给变量赋值，如:<blockquote>
<p>for file in <code>ls /etc</code><br>  以上语句将 /etc 下目录的文件名循环出来</p>
</blockquote>
</li>
<li>使用变量<br>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：<blockquote>
<p>your_name=”qinjx”<br>echo $your_name<br>echo ${your_name}<br>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况</p>
</blockquote>
</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/02/28/Shell教程/">
    <time datetime="2018-02-28T10:36:25.000Z" class="entry-date">
        2018-02-28
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="关于route-Router" class="关于route-Router post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/02/10/Router/">关于Router and Route</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://fzzkiddy.github.io/2018/02/10/Router/" data-id="ck5nh1p000006i2cdshbe51se" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><ul>
<li><code>&lt;BrowserRouter&gt;</code><br>一个使用了 HTML5 history API 的高阶路由组件，保证你的 UI 界面和 URL 保持同步。此组件拥有以下属性：<br>basename: string<br>作用：为所有位置添加一个基准URL<br>使用场景：假如你需要把页面部署到服务器的二级目录，你可以使用 basename 设置到此目录。<pre><code>&lt;BrowserRouter basename=&quot;/minooo&quot; /&gt;
 &lt;Link to=&quot;/react&quot; /&gt; 
 // 最终渲染为 &lt;a href=&quot;/minooo/react&quot;&gt;
</code></pre><ul>
<li><code>getUserConfirmation: func</code><br>作用：导航到此页面前执行的函数，默认使用 window.confirm<br>使用场景：当需要用户进入页面前执行什么操作时可用，不过一般用到的不多。<br>  const getConfirmation = (message, callback) =&gt; {<pre><code>  const allowTransition = window.confirm(message)
  callback(allowTransition)}
&lt;BrowserRouter getUserConfirmation={getConfirmation(&apos;Are you sure?&apos;, yourCallBack)} /&gt;
</code></pre></li>
</ul>
</li>
<li><p><code>&lt;Route&gt;</code><br>  自带三个 render method 和三个 props</p>
<p>  render methods 分别是：</p>
<ul>
<li>&lt;Route component&gt;</li>
<li>&lt;Route render&gt;</li>
<li><p>&lt;Route children&gt;</p>
<p>props 分别是：</p>
</li>
<li>match</li>
<li>location</li>
<li><p>history</p>
<p>所有的 render method 无一例外都将被传入这些 props</p>
<p>component<br>  只有当访问地址和路由匹配时，一个React component 才会被渲染，此时此组件接受 route props（match，loction，history）</p>
</li>
</ul>
</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/02/10/Router/">
    <time datetime="2018-02-10T06:04:05.000Z" class="entry-date">
        2018-02-10
    </time>
</a>
    
    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2020/01/21/2020年终总结/">2020年终总结</a>
          </li>
        
          <li>
            <a href="/2018/07/11/webpack入门/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/07/10/CommonJs/">CommonJs</a>
          </li>
        
          <li>
            <a href="/2018/07/09/npm/">npm</a>
          </li>
        
          <li>
            <a href="/2018/07/09/图片预加载/">图片预加载</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2020 Fzz Kiddy
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>